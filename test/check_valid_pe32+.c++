/**
 * @file check_valid_pe32+.c++
 * @author Joshua Buchanan (joshuarobertbuchanan@gmail.com)
 * @brief Checks for a valid EFI image (these are PE32+ formatted images)
 * @version 1
 * @date 2023-04-16
 *
 * @copyright Copyright (C) 2023. Intellectual property of the author(s) listed above.
 *
 */

#include <chrono>
#include <cstddef>
#include <cstdint>
#include <fstream>
#include <iostream>
#include <iterator>
#include <sstream>
#include <string>
#include <vector>

bool check_file( std::ifstream & );

int main( int const argc, char const *const *const argv ) {
    bool processed_any_files = false;
    bool all_passed          = true;
    for ( int i = 1; i < argc; i++ ) {
        std::ifstream fstream { argv [ i ] };
        if ( fstream.good( ) ) {
            std::cout << "Checking " << argv [ i ] << "\n";
            processed_any_files    = true;
            bool this_file_passed  = check_file( fstream );
            all_passed            &= this_file_passed;
            if ( argv [ i ] == std::string( "testfiles/BOOTTEST.EFI" ) && !this_file_passed ) {
                std::cout << "The most recent file to fail was one generated by Microsoft's link.exe, you know, the "
                             "Microsoft-made tool to output a Microsoft-made file format.\n";
                std::cout << "Since Microsoft both made link.exe and the PE32+ format, Garbage OS considers it to be "
                             "the ultimate authority in making valid PE32+ files.\n";
                std::cout << "TL;DR: we failed a file that should always pass, so really the file failed us.\n";
                return -2;
            }
        } else {
            std::cout << "File does not exist: " << argv [ i ] << ". So it cannot be a valid PE32+\n";
            return -1;
        }
    }

    if ( !processed_any_files ) {
        std::cout << "No files procesed, so no files passed.\n";
        return -1;
    } else if ( !all_passed ) {
        std::cout << "Not all files passed. See above for details.\n";
        return -1;
    } else {
        std::cout << "All files passed. Check above for any notes.\n";
        return 0;
    }
}

struct ms_dos_2_stub {
    std::uint8_t literally_m;
    std::uint8_t literally_z;
    std::uint8_t offset_of_signature;
};

struct pe_signature {
    std::uint8_t  pe_string [ 4 ];
    std::uint16_t machine;
    std::uint16_t section_count;
    std::uint32_t timestamp;
    std::uint32_t symbol_offset_and_count [ 2 ];
    std::uint16_t optional_header_size;
    std::uint16_t characteristics;
};

/**
 * @brief Ironically not optional
 *
 */
struct optional_header {
    std::uint16_t magic_number;
    std::uint8_t  linker_major_version;
    std::uint8_t  linker_minor_version;
    std::uint32_t size_of_code;
    std::uint32_t size_of_initialized_data;
    std::uint32_t size_of_uninitialized_data;
    std::uint32_t address_of_entry_point;
    std::uint32_t base_of_code;
    std::uint64_t image_base;
    std::uint32_t section_alignment;
    std::uint32_t file_alignment;
    std::uint16_t major_os_version;
    std::uint16_t minor_os_version;
    std::uint16_t major_image_version;
    std::uint16_t minor_image_version;
    std::uint16_t major_subsystem_version;
    std::uint16_t minor_subsystem_version;
    std::uint32_t win32_version;
    std::uint32_t image_size;
    std::uint32_t size_of_headers;
    std::uint32_t checksum;
    std::uint16_t subsystem;
    std::uint16_t dll_characteristics;
    std::uint64_t stack_reserve;
    std::uint64_t stack_commit;
    std::uint64_t heap_reserve;
    std::uint64_t heap_commit;
    std::uint32_t loader_flags;
    std::uint32_t rva_count_and_sizes;
};

static_assert( sizeof( optional_header ) == 112, "You forgot some fields!" );

struct data_directory_table {
    std::uint32_t address;
    std::uint32_t size;
};

struct data_directory_tables {
    data_directory_table export_table;
    data_directory_table import_table;
    data_directory_table resource_table;
    data_directory_table exception_table;
    data_directory_table certificate_table;
    data_directory_table base_relocation_table;
    data_directory_table debug_table;
    data_directory_table architecture_table;
    data_directory_table global_pointer_table;
    data_directory_table thread_local_storage_table;
    data_directory_table load_config_table;
    data_directory_table bound_import_table;
    data_directory_table import_address_table;
    data_directory_table delay_import_descriptor;
    data_directory_table common_language_runtime_header_table;
    data_directory_table reserved_table;
};

struct machine_type_data {
    std::string   name;
    std::uint16_t field_value;
    bool          expected_in_efi;
};

static machine_type_data machine_types [] = {
        {                                         "unknown", 0x0000, false},
        {                                             "x64", 0x8664,  true},
        {                                           "IA-32", 0x014C,  true},
        {                                           "IA-64", 0x0200,  true},
        {"ARM / Thumb (EFI reads as ARM, Windows as Thumb)", 0x01C2,  true},
        {                                         "aarch64", 0xAA64,  true},
        {                                        "riscv-32", 0x5032,  true},
        {                                        "riscv-64", 0x5064,  true},
        {                                       "riscv-128", 0x5128,  true},
        {                                    "LoongArch-32", 0x6232,  true},
        {                                    "LoongArch-64", 0x6264,  true},
};

class not_valid_pep {
    std::string reason;

public:
    not_valid_pep( std::string const &reason ) : reason { reason } {
    }

    std::string why( ) const noexcept {
        return reason;
    }
};

std::uint8_t read_byte( std::vector<std::uint8_t>::const_iterator const &from, std::size_t offset = 0 ) {
    return *( from + offset );
}

void read_generic( std::vector<std::uint8_t>::const_iterator const &from,
                   std::unsigned_integral auto                     &into,
                   std::size_t                                      offset        = 0,
                   bool                                             little_endian = true ) {
    std::size_t highest_byte_shift = 8 * ( sizeof( into ) - 1 );
    into                           = 0;
    for ( std::size_t i = 0; i < sizeof( into ); i++ ) {
        if ( little_endian ) {
            into >>= 8;
        } else {
            into <<= 8;
        }
        into |= ( (std::remove_reference_t<decltype( into )>) read_byte( from, offset + i ) )
             << ( little_endian ? highest_byte_shift : 0 );
    }
}

template <std::unsigned_integral integer>
void read_into( std::vector<std::uint8_t>::const_iterator const &from,
                std::output_iterator<integer> auto const        &start,
                std::output_iterator<integer> auto const        &end,
                std::size_t                                      offset        = 0,
                bool                                             little_endian = true ) {
    for ( auto i = start; i < end; i++ ) { read_generic( from, *i, offset + ( i - start ), little_endian ); }
}

ms_dos_2_stub extract_ms_dos_2( std::vector<std::uint8_t>::const_iterator const &from, std::size_t offset = 0 ) {
    ms_dos_2_stub found;
    found.literally_m         = read_byte( from + offset, 0 );
    found.literally_z         = read_byte( from + offset, 1 );
    found.offset_of_signature = read_byte( from + offset, 0x3C );

    if ( found.literally_m != 'M' ) {
        std::stringstream message;
        message << "First byte is not 'M' but " << found.literally_m;
        message << " (" << std::hex << (unsigned) found.literally_m << ")";
        throw not_valid_pep( message.str( ) );
    }

    if ( found.literally_z != 'Z' ) {
        std::stringstream message;
        message << "Second byte is not 'Z' but " << found.literally_z;
        message << " (" << std::hex << (unsigned) found.literally_z << ")";
        throw not_valid_pep( message.str( ) );
    }

    if ( found.offset_of_signature < 0x3D ) {
        std::stringstream message;
        message << "PE offset byte (byte at offset 0x3C) indicates that the PE";
        message << " parts of the file start BEFORE the end of the MS DOS 2.0 ";
        message << "compatibility stub, at offset " << (unsigned) found.offset_of_signature;
        throw not_valid_pep( message.str( ) );
    }

    return found;
}

pe_signature extract_signature( std::vector<std::uint8_t>::const_iterator const &from, std::size_t offset = 0 ) {
    pe_signature signature;

    read_into<std::uint8_t>( from,
                             std::begin( signature.pe_string ),
                             std::end( signature.pe_string ),
                             offset + offsetof( pe_signature, pe_string ) );
    read_generic( from, signature.machine, offset + offsetof( pe_signature, machine ) );
    read_generic( from, signature.section_count, offset + offsetof( pe_signature, section_count ) );
    read_generic( from, signature.timestamp, offset + offsetof( pe_signature, timestamp ) );
    read_into<std::uint32_t>( from,
                              std::begin( signature.symbol_offset_and_count ),
                              std::end( signature.symbol_offset_and_count ),
                              offset + offsetof( pe_signature, symbol_offset_and_count ) );
    read_generic( from, signature.optional_header_size, offset + offsetof( pe_signature, optional_header_size ) );
    read_generic( from, signature.characteristics, offset + offsetof( pe_signature, characteristics ) );

    bool type_was_seen = false;
    for ( auto type : machine_types ) {
        if ( type.field_value == signature.machine ) {
            std::cout << "\tFile identifies itself as a(n) " << type.name << ", which is ";
            if ( !type.expected_in_efi ) { std::cout << "NOT "; }
            std::cout << "expected in an EFI loader. Check that this matches what the name of the file indicates.\n";
            type_was_seen = true;
            break;
        }
    }

    if ( !type_was_seen ) {
        std::stringstream message;
        message << "Machine type field is 0x" << std::hex << signature.machine << ". Which is not known to Garbage OS";
        message << " and likely not to any firmware either.";
        throw not_valid_pep( message.str( ) );
    }

    if ( signature.section_count < 1 ) {
        std::stringstream message;
        message << "Section count field is 0, which implies that this file contains nothing."
                << " That does not make logical sense.";
        throw not_valid_pep( message.str( ) );
    }

    std::cout << "\tFile says it was compiled " << std::dec << signature.timestamp
              << " seconds after the last time that the posix time rolled over.\n";
    auto now = std::chrono::steady_clock::now( ).time_since_epoch( ).count( );
    std::cout << "\tFor context, " << now / 1'000'000 << " seconds have elapsed since the posix epoch.\n";

    if ( ( signature.characteristics & 0x0002 ) == 0 ) {
        std::stringstream message;
        message << "\tThe File says that it is not executible. That's a problem.";
        throw not_valid_pep( message.str( ) );
    }

    if ( ( signature.characteristics & 0x0020 ) == 0 ) {
        std::stringstream message;
        message << "\tThe File does not say that it can handle large addresses. That's a problem.";
        // Commented out during testing the linker script because objcopy gets
        // this wrong.
        throw not_valid_pep( message.str( ) );
    }

    return signature;
}

optional_header extract_optional_header( std::vector<std::uint8_t>::const_iterator const &from, std::size_t offset = 0 ) {
    optional_header                           header;
    std::vector<std::uint8_t>::const_iterator iterator = from + offset;
    read_generic( iterator, header.magic_number, offsetof( optional_header, magic_number ) );
    read_generic( iterator, header.linker_major_version, offsetof( optional_header, linker_major_version ) );
    read_generic( iterator, header.linker_minor_version, offsetof( optional_header, linker_minor_version ) );
    read_generic( iterator, header.size_of_code, offsetof( optional_header, size_of_code ) );
    read_generic( iterator, header.size_of_code, offsetof( optional_header, size_of_code ) );
    read_generic( iterator, header.size_of_initialized_data, offsetof( optional_header, size_of_initialized_data ) );
    read_generic( iterator, header.size_of_uninitialized_data, offsetof( optional_header, size_of_uninitialized_data ) );
    read_generic( iterator, header.address_of_entry_point, offsetof( optional_header, address_of_entry_point ) );
    read_generic( iterator, header.base_of_code, offsetof( optional_header, base_of_code ) );

    read_generic( iterator, header.image_base, offsetof( optional_header, image_base ) );
    read_generic( iterator, header.section_alignment, offsetof( optional_header, section_alignment ) );
    read_generic( iterator, header.file_alignment, offsetof( optional_header, file_alignment ) );
    read_generic( iterator, header.major_os_version, offsetof( optional_header, major_os_version ) );
    read_generic( iterator, header.minor_os_version, offsetof( optional_header, minor_os_version ) );
    read_generic( iterator, header.major_image_version, offsetof( optional_header, major_image_version ) );
    read_generic( iterator, header.minor_image_version, offsetof( optional_header, minor_image_version ) );
    read_generic( iterator, header.major_subsystem_version, offsetof( optional_header, major_subsystem_version ) );
    read_generic( iterator, header.minor_subsystem_version, offsetof( optional_header, minor_subsystem_version ) );
    read_generic( iterator, header.win32_version, offsetof( optional_header, win32_version ) );
    read_generic( iterator, header.image_size, offsetof( optional_header, image_size ) );
    read_generic( iterator, header.size_of_headers, offsetof( optional_header, size_of_headers ) );
    read_generic( iterator, header.checksum, offsetof( optional_header, checksum ) );
    read_generic( iterator, header.subsystem, offsetof( optional_header, subsystem ) );
    read_generic( iterator, header.dll_characteristics, offsetof( optional_header, dll_characteristics ) );
    read_generic( iterator, header.stack_reserve, offsetof( optional_header, stack_reserve ) );
    read_generic( iterator, header.stack_commit, offsetof( optional_header, stack_commit ) );
    read_generic( iterator, header.heap_reserve, offsetof( optional_header, heap_reserve ) );
    read_generic( iterator, header.heap_commit, offsetof( optional_header, heap_commit ) );
    read_generic( iterator, header.loader_flags, offsetof( optional_header, loader_flags ) );
    read_generic( iterator, header.rva_count_and_sizes, offsetof( optional_header, rva_count_and_sizes ) );

    if ( header.magic_number != 0x020B ) {
        std::stringstream message;
        message << "The file's optional header says that it's magic number is 0x" << std::hex << header.magic_number
                << std::dec;
        message << " this is not the magic number required for an EFI Application of 0x020B\n";
        throw not_valid_pep( message.str( ) );
    }
    std::cout << "\tFile reports its linker version as " << (unsigned) header.linker_major_version << "."
              << (unsigned) header.linker_minor_version << "\n";

    if ( header.size_of_code < 1'024 ) {
        if ( header.size_of_code == 0 ) {
            std::stringstream message;
            message << "File reports that it has no code, or, more precisely, that its code takes up no space.\n";
            // objcopy sets the size of the code to zero.
            throw not_valid_pep( message.str( ) );
        }
        std::cout << "\tFile reports that it has less than 1KiB of code inside... that's kinda sus, but allowed.\n";
    }

    if ( header.size_of_initialized_data < 1'024 ) {
        if ( header.size_of_initialized_data == 0 ) {
            std::stringstream message;
            message << "File reports that it has no initialized data (constants), or, more precisely, that its data "
                       "takes up no space.\n";
            // objcopy sets the size of initialized data to zero.
            throw not_valid_pep( message.str( ) );
        }
        std::cout << "\tFile reports that it has less than 1KiB of constants, perhaps include more images? Honkai Star "
                     "Rail takes up >8GiB at launch. That's satire. Good job at the small file?\n";
    }

    if ( header.size_of_uninitialized_data < 1'024 ) {
        // since link.exe veritably will output that there is no uninitialized
        // data. This is not ever an error.
        std::cout << "\tFile reports that it has less than 1KiB of variables at the namespace scope, i.e., \"global if "
                     "you include the file\" scope. That's kinda sus.\n";
    }

    if ( header.address_of_entry_point == 0 ) {
        std::stringstream message;
        message << "File reports that it either has no entry point or that that entry point is genuinely at the first "
                   "byte of the image.";
        message << "Since a value of zero can be interpreted as \"no entry point\" this is a problem.\n";
        throw not_valid_pep( message.str( ) );
    }
    std::cout << "\tFile entry point reported to be at image base + 0x" << std::hex << header.address_of_entry_point
              << std::dec << "\n";
    if ( header.base_of_code > header.address_of_entry_point ) {
        std::stringstream message;
        message << "File reports that its entry point starts before the code starts. THE FILE SAYS ITS MAIN FUNCTION "
                   "IS NOT CODE.\n";
        throw not_valid_pep( message.str( ) );
    }
    std::cout << "\tFile code base reported to be at image base + 0x" << std::hex << header.base_of_code << std::dec << "\n";
    std::cout << "\tFile's entry point offset into code: " << header.address_of_entry_point - header.base_of_code << "\n";

    if ( ( header.image_base & 0x1'0000 ) != 0 ) {
        std::stringstream message;
        message << "File requests to be loaded in starting at address 0x" << std::hex << header.image_base << std::dec << ", ";
        message << "which is not a multiple of 65536 (hex 0x" << std::hex << 0x1'0000 << std::dec << ")";
        throw not_valid_pep( message.str( ) );
    }

    std::cout << "\tFile indicates that it's preferred starting address is 0x" << std::hex << header.image_base
              << std::dec << "\n";

    // check that file alignment is a power of 2.
    // subtracting 1 from any power of 2 and then performing bitwise and
    // always gets zero. You can check yourself.
    // the reason is that if we have a number in binary with n bits set from
    // bit zero, adding 1 gets a power of 2 and bits 0 to n are now zero.
    // as such, the one bit set in the power of 2 gets masked out by the value
    // one below and all bits in the value one below get masked out since they
    // are zero in the power of 2.
    if ( ( header.file_alignment & ( header.file_alignment - 1 ) ) != 0 ) {
        std::stringstream message;
        message << "File indicates that the file alignment should be 0x" << std::hex << header.file_alignment
                << std::dec << " which is not a power of 2. This value is required to be a power of 2.";
        throw not_valid_pep( message.str( ) );
    }

    // minimum file alignment is 512 bytes
    if ( header.file_alignment < 512 ) {
        std::stringstream message;
        message << "File indicates its file alignment should be " << header.file_alignment
                << " bytes, which is less than the minimum of 512.";
        throw not_valid_pep( message.str( ) );
    }

    // maximum file alignment is 64KiB
    if ( header.file_alignment > 0x1'0000 ) {
        std::stringstream message;
        message << "File indicates its file alignment should be " << header.file_alignment
                << " bytes, which is larger than the maximum of 65536 (64KiB)";
        throw not_valid_pep( message.str( ) );
    }

    // section alignment is always >= file alignment
    // additionally, if section alignment < 4096, then
    // file alignment == section_alignment
    if ( header.section_alignment < header.file_alignment ) {
        std::stringstream message;
        message << "File requests a section alignment of " << header.section_alignment
                << " bytes which is less than the file alignment of " << header.file_alignment << "bytes.\n";
        throw not_valid_pep( message.str( ) );
    }

    if ( header.section_alignment < 0x1000 && header.file_alignment != header.section_alignment ) {
        std::stringstream message;
        message << "File requests a file alignment of " << header.file_alignment << " and a section alignment of "
                << header.section_alignment
                << ". These are not equal. While this could be valid on some systems, the section alignment is smaller "
                   "than the EFI defined pages size of 4096 bytes so it's invalid.";
        throw not_valid_pep( message.str( ) );
    }

    std::cout << "\tFile reports a minimum OS version to run of " << header.major_os_version << "."
              << header.minor_os_version << "\n";

    std::cout << "\tFile reports an image version of " << header.major_image_version << "."
              << header.minor_image_version << "\n";

    std::cout << "\tFile reports a subsystem version of " << header.major_subsystem_version << "."
              << header.minor_subsystem_version << "\n";

    if ( header.win32_version != 0 ) {
        std::stringstream message;
        message << "The reserved Win32VersionValue field which should be zero is not zero but 0x" << std::hex
                << header.win32_version << std::dec;
        throw not_valid_pep( message.str( ) );
    }

    if ( header.image_size % header.section_alignment != 0 ) {
        std::stringstream message;
        message << "The file says that it's image size in memory is " << header.image_size
                << " bytes, but this is not a multiple of the section alignment of " << header.section_alignment << ".";
        throw not_valid_pep( message.str( ) );
    }

    if ( header.size_of_headers % header.file_alignment != 0 ) {
        std::stringstream message;
        message << "The file says that it's header size in memory is " << header.size_of_headers
                << " bytes, but this is not a multiple of the section alignment of " << header.file_alignment << ".";
        throw not_valid_pep( message.str( ) );
    }

    std::cout << "\tFile says its checksum is 0x" << std::hex << header.checksum << std::dec << " this might not be used.\n";

    if ( header.subsystem != 10 ) {
        std::stringstream message;
        message << "The file says that its subsystem is " << header.subsystem
                << ", which is not the EFI subsystem's number of 10.";
        throw not_valid_pep( message.str( ) );
    }

    std::cout << "\tFile requests a reserved stack size of " << header.stack_reserve / 1024.0 << "KiB\n";
    std::cout << "\tFile requests a committed stack size of " << header.stack_commit / 1024.0 << "KiB\n";
    std::cout << "\tFile requests a reserved heap size of " << header.heap_reserve / 1024.0 << "KiB\n";
    std::cout << "\tFile requests a committed heap size of " << header.heap_commit / 1024.0 << "KiB\n";

    if ( header.loader_flags != 0 ) {
        std::stringstream message;
        message << "File has a nonzero loader flags field. This field is reserved and must be zero.";
        throw not_valid_pep( message.str( ) );
    }

    if ( header.rva_count_and_sizes > 16 ) {
        std::stringstream message;
        message << "File says that there are >16 RVA tables. There are only up to 16 possible tables.";
        throw not_valid_pep( message.str( ) );
    }
    std::cout << "\tFile indicates that " << header.rva_count_and_sizes << " remaining data directory entries exist.\n";

    return header;
}

data_directory_table
        extract_data_directory_table( std::vector<std::uint8_t>::const_iterator const &iterator, std::size_t offset = 0 ) {
    data_directory_table the_table;
    read_generic( iterator + 0, the_table.address, offset );
    read_generic( iterator + 4, the_table.size, offset );
    return the_table;
}

data_directory_tables extract_data_directory_tables( std::vector<std::uint8_t>::const_iterator const &iterator,
                                                     std::size_t                                      offset = 0,
                                                     std::size_t table_count                                 = 0 ) {
    data_directory_tables tables = {
            extract_data_directory_table( iterator, offset + 0 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 1 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 2 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 3 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 4 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 5 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 6 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 7 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 8 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 9 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 10 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 11 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 12 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 13 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 14 * sizeof( data_directory_table ) ),
            extract_data_directory_table( iterator, offset + 15 * sizeof( data_directory_table ) ),
    };

    switch ( table_count ) {
    case 16:
        // 16th table is the reserved table.
        if ( tables.reserved_table.address != 0 ) {
            std::stringstream message;
            message << "The address of table #16, the reserved table, is not zero.";
            throw not_valid_pep( message.str( ) );
        }
        if ( tables.reserved_table.size != 0 ) {
            std::stringstream message;
            message << "The size of table #16, the reserved table, is not zero.";
            throw not_valid_pep( message.str( ) );
        }
        std::cout << "\tFile's reserved table matches the expected all zeros.\n";
        [[fallthrough]];
    case 15:
        if ( tables.common_language_runtime_header_table.address != 0 ) {
            std::stringstream message;
            message << "The Common Language Runtime Header table is only allowed for object files, but its addresss "
                       "was not zero, indicating that the table in fact exists.";
            throw not_valid_pep( message.str( ) );
        }
        if ( tables.common_language_runtime_header_table.size != 0 ) {
            std::stringstream message;
            message << "The Common Language Runtime Header table is only allowed for object files, but its size was "
                       "not zero, indicating that the table in fact exists.";
            throw not_valid_pep( message.str( ) );
        }
        std::cout << "\tFile's Common Language Runtime Header matches the expected all zeros.\n";
        [[fallthrough]];
    case 14:
        if ( tables.delay_import_descriptor.address != 0 ) {
            std::stringstream message;
            message << "The delay import descriptor table has a nonzero address, implying that this program calls a "
                       "function in a DLL file. Those don't exist in EFI.";
            throw not_valid_pep( message.str( ) );
        }
        if ( tables.delay_import_descriptor.size != 0 ) {
            std::stringstream message;
            message << "The delay import descriptor table has a nonzero size, implying that this program calls a "
                       "function in a DLL file. Those don't exist in EFI.";
            throw not_valid_pep( message.str( ) );
        }
        std::cout << "\tFile's Delay Import Descriptor Table matches the expected all zeros.\n";
        [[fallthrough]];
    case 13:
        if ( tables.import_address_table.address != 0 ) {
            std::stringstream message;
            message << "The Import Address Table has a nonzero address, implying that this program will try to bind to "
                       "DLL files. Those don't exist in EFI.";
            throw not_valid_pep( message.str( ) );
        }
        if ( tables.import_address_table.size != 0 ) {
            std::stringstream message;
            message << "The Import Address Table has a nonzero size, implying that this program will try to bind to "
                       "DLL files. Those don't exist in EFI.";
            throw not_valid_pep( message.str( ) );
        }
        std::cout << "\tFile's Import Address Table matches the expected all zeros.\n";
        [[fallthrough]];
    case 12:
        if ( tables.bound_import_table.address != 0 ) {
            std::stringstream message;
            message << "The Bound Import Table has a nonzero address, implying that this program will try to bind to "
                       "DLL files. Those don't exist in EFI.";
            throw not_valid_pep( message.str( ) );
        }
        if ( tables.bound_import_table.size != 0 ) {
            std::stringstream message;
            message << "The Bound Import Table has a nonzero size, implying that this program will try to bind to "
                       "DLL files. Those don't exist in EFI.";
            throw not_valid_pep( message.str( ) );
        }
        std::cout << "\tFile's Bound Import Table matches the expected all zeros.\n";
        [[fallthrough]];
    case 11:

        [[fallthrough]];
    case 10:

        [[fallthrough]];
    case 9:

        [[fallthrough]];
    case 8:

        [[fallthrough]];
    case 7:

        [[fallthrough]];
    case 6:

        [[fallthrough]];
    case 5:

        [[fallthrough]];
    case 4:

        [[fallthrough]];
    case 3:

        [[fallthrough]];
    case 2:

        [[fallthrough]];
    case 1:

        break;
    case 0:
        std::cout << "\tFile has no RVA tables.\n";
        break;
    default: /* > 16 */
    {
        std::stringstream message;
        message << "Only 16 entries are allowed in the data directory tables, but found " << table_count << " entries instead.";
        throw not_valid_pep( message.str( ) );
    }
    }

    return tables;
}

bool check_file( std::ifstream &file ) {
    std::vector<std::uint8_t> bytes;
    while ( !file.eof( ) ) {
        std::uint8_t temp;
        temp = (std::uint8_t) file.get( );
        bytes.push_back( temp );
    }

    auto start_of_bytes = bytes.cbegin( );
    try {
        ms_dos_2_stub stub                      = extract_ms_dos_2( start_of_bytes, 0 );
        std::size_t   signature_offset          = stub.offset_of_signature;
        start_of_bytes                         += signature_offset;
        pe_signature signature                  = extract_signature( start_of_bytes, 0 );
        start_of_bytes                         += sizeof( signature );
        optional_header mandatory_header        = extract_optional_header( start_of_bytes, 0 );
        start_of_bytes                         += sizeof( mandatory_header );
        std::size_t data_directory_table_count  = mandatory_header.rva_count_and_sizes;
        extract_data_directory_tables( start_of_bytes, 0, data_directory_table_count );
        start_of_bytes += data_directory_table_count * sizeof( data_directory_table );

    } catch ( not_valid_pep why_its_invalid ) {
        std::cout << "\tFile was found to be invalid because: " << why_its_invalid.why( ) << "\n";
        return false;
    }

    std::cout << "\tFile may be accepted, nothing said it's invalid but notes may have been emitted.\n";
    return true;
}